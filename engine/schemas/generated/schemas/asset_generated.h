// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASSET_ENGINE_SCHEMAS_H_
#define FLATBUFFERS_GENERATED_ASSET_ENGINE_SCHEMAS_H_

#include "flatbuffers/flatbuffers.h"

#include "schemas/exo_generated.h"

namespace engine {
namespace schemas {

struct Asset;
struct AssetBuilder;

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4
  };
  const engine::schemas::exo::UUID *uuid() const {
    return GetStruct<const engine::schemas::exo::UUID *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<engine::schemas::exo::UUID>(verifier, VT_UUID) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  typedef Asset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(const engine::schemas::exo::UUID *uuid) {
    fbb_.AddStruct(Asset::VT_UUID, uuid);
  }
  explicit AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Asset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    const engine::schemas::exo::UUID *uuid = nullptr) {
  AssetBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

}  // namespace schemas
}  // namespace engine

#endif  // FLATBUFFERS_GENERATED_ASSET_ENGINE_SCHEMAS_H_
