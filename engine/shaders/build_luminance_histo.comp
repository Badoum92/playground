#include "globals.h"
#include "constants.h"

#if 0
layout (buffer_reference) buffer HistogramType {
    uint values[];
};
#endif

layout (set = 1, binding = 1) buffer HistogramBuffer {
    uint values[];
} luminance_buffer;

layout (set = 1, binding = 0) uniform LUM
{
    #if 0
    HistogramType luminance_buffer_ptr;
    #else
    u32 mdr0;
    u32 mdr1;
    #endif
    float min_log_luminance;
    float one_over_log_luminance_range;
    uint  sampled_hdr_texture;
};

float get_luminance(float3 color)
{
    return dot(color, float3(0.2127f, 0.7152f, 0.0722f));
}

uint hdr_to_histogram_bin(float3 color)
{
    float luminance = get_luminance(color);

    if (luminance < 0.01)
    {
        return 0;
    }

    float log_luminance = clamp((log2(luminance) - min_log_luminance) * one_over_log_luminance_range, 0.0, 1.0);
    return uint(log_luminance * 254.0 + 1.0);
}

shared uint histogram_shared[256];

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uint local_idx = gl_LocalInvocationIndex;
    uint3 thread_id = gl_GlobalInvocationID;

    // every invocation of this group will clear the shared memory to 0
    histogram_shared[local_idx] = 0;

    groupMemoryBarrier();
    barrier();

    // every global invocation maps to one pixel of the input texture
    // add it to the histogram
    int2 pixel_pos = int2(thread_id.xy);
    int2 input_size = textureSize(global_textures[sampled_hdr_texture], LOD0);
    if(all(lessThan(pixel_pos, input_size)))
    {
        float3 hdr_color = texelFetch(global_textures[sampled_hdr_texture], pixel_pos, 0).rgb;
        uint bin_idx = hdr_to_histogram_bin(hdr_color);

        atomicAdd(histogram_shared[bin_idx], 1);
    }

    groupMemoryBarrier();
    barrier();

    // the local shared histogram is full now,
    // so add the shared histogram to the global one
    atomicAdd(luminance_buffer.values[local_idx], histogram_shared[local_idx]);
}
