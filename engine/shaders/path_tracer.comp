#version 460
#extension GL_GOOGLE_include_directive : require

#include "globals.h"
#include "hash.h"
#include "raytracing.h"
#include "pbr.h"

layout(set = SHADER_SET, binding = 0) uniform Options {
    u32 storage_output;
};


struct HitInfo
{
    float d;
    u32 box_inter_count;
    float3 barycentrics;
    u32 triangle_id;
    u32 instance_id;
};

bool blas_closest_hit(Ray ray, u32 i_instance, out HitInfo hit_info)
{
    hit_info.d = 1.0 / 0.0;
    hit_info.box_inter_count = 0;
    hit_info.barycentrics = float3(0.0);
    hit_info.triangle_id = u32_invalid;
    hit_info.instance_id = u32_invalid;

    RenderInstance instance = get_render_instance(i_instance);
    RenderMesh mesh = get_render_mesh(instance.i_render_mesh);

    ray.origin    = (instance.world_to_object * float4(ray.origin, 1.0)).xyz;
    ray.direction = (instance.world_to_object * float4(ray.direction, 0.0)).xyz;

    float3 inv_ray_dir = 1.0 / ray.direction;

    uint i_node = 0;
    while (i_node != u32_invalid)
    {
        BVHNode node = get_blas_node(mesh.bvh_root, i_node);

        if (node.prim_index != u32_invalid)
        {
            u32    i_v0 = get_index(mesh.first_index + node.prim_index + 0);
            u32    i_v1 = get_index(mesh.first_index + node.prim_index + 1);
            u32    i_v2 = get_index(mesh.first_index + node.prim_index + 2);
            float3 p0   = get_position(mesh.first_position, i_v0).xyz;
            float3 p1   = get_position(mesh.first_position, i_v1).xyz;
            float3 p2   = get_position(mesh.first_position, i_v2).xyz;

            float d = 0.0;
            Triangle tri;
            tri.v0 = p0;
            tri.e0 = p1 - p0;
            tri.e1 = p2 - p0;
            float3 barycentrics = triangle_intersection(ray, tri, d);

            if (0.0 < d && d < hit_info.d)
            {
                hit_info.d            = d;
                hit_info.barycentrics = barycentrics;
                hit_info.triangle_id  = node.prim_index;
            }
        }
        else
        {
            bool hit_bbox = fast_box_intersection(node.bbox_min, node.bbox_max, ray, inv_ray_dir);
            if (hit_bbox)
            {
                hit_info.box_inter_count += 1;
                i_node += 1;
                continue;
            }
        }

        // the ray missed the triangle or the node's bounding box, skip the subtree
        i_node = node.next_node;
    }

    return hit_info.d < 1.0 / 0.0;
}

bool tlas_closest_hit(Ray ray, out HitInfo hit_info)
{
    float3 inv_ray_dir = 1.0 / ray.direction;

    hit_info.d = 1.0 / 0.0;
    hit_info.box_inter_count = 0;
    hit_info.barycentrics = float3(0.0);
    hit_info.triangle_id = u32_invalid;
    hit_info.instance_id = u32_invalid;

    uint i_node = 0;
    uint iter = 0;
    while (i_node != u32_invalid && iter < 500)
    {
        iter += 1;

        BVHNode node = get_tlas_node(i_node);

        bool hit_bbox = fast_box_intersection(node.bbox_min, node.bbox_max, ray, inv_ray_dir);
        if (hit_bbox)
        {
            hit_info.box_inter_count += 1;

            if (node.prim_index != u32_invalid)
            {
                HitInfo leaf_hit_info;
                // intersect primitive
                bool hit_leaf = blas_closest_hit(ray, node.prim_index, leaf_hit_info);
                hit_info.box_inter_count += leaf_hit_info.box_inter_count;
                if (leaf_hit_info.d < hit_info.d)
                {
                    hit_info.instance_id = node.prim_index;
                    hit_info.d = leaf_hit_info.d;
                    hit_info.barycentrics = leaf_hit_info.barycentrics;
                    hit_info.triangle_id  = leaf_hit_info.triangle_id;
                }
                i_node = node.next_node;
            }
            else
            {
                i_node += 1;
                continue;
            }
        }

        i_node = node.next_node;
    }

    return hit_info.d < 1.0 / 0.0;
}

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uint  local_idx  = gl_LocalInvocationIndex;
    uint3 global_idx = gl_GlobalInvocationID;
    uint3 group_idx  = gl_WorkGroupID;

    int2 pixel_pos = int2(global_idx.xy);
    int2 output_size = imageSize(global_images_2d_rgba32f[storage_output]);

    if (any(greaterThan(pixel_pos, output_size)))
    {
        return;
    }

    float2 screen_uv  = (float2(pixel_pos) + float2(0.5)) / float2(output_size);
    float3 clip_space = float3(screen_uv * 2.0 - 1.0, 1.0);

    // TAA jitter
    float2 texel_size = 1.0 / float2(output_size);
    float2 current_jitter = globals.jitter_offset * texel_size;
    clip_space.xy += current_jitter;

    // Create a pixel ray
    float4x4 view_rows = transpose(globals.camera_view);
    float aspect_ratio = globals.camera_projection[1][1] / globals.camera_projection[0][0];
    float tan_half_fov_y = 1.0 / globals.camera_projection[1][1];
    Ray ray;
    ray.t_min = 0.0;
    ray.t_max = 1.0 / 0.0;
    ray.origin    = globals.camera_view_inverse[3].xyz;
    ray.direction =
        + (clip_space.x * tan_half_fov_y * aspect_ratio) * view_rows[0].xyz
        + (clip_space.y * tan_half_fov_y) * view_rows[1].xyz
        - view_rows[2].xyz;

    uint rng_seed = init_seed(pixel_pos, globals.frame_count);

    const uint MAX_BOUNCE = 2;
    const float3 BACKGROUND_COLOR = float3(1.0);
    uint hit_count = 0;
    HitInfo hit_info;
    float3 radiance = float3(0.0);
    float3 throughput = float3(1.0);

    for (u32 i_bounce = 0; i_bounce < MAX_BOUNCE; i_bounce += 1)
    {

        if (tlas_closest_hit(ray, hit_info) == false)
        {
            radiance = BACKGROUND_COLOR * throughput;
            break;
        }

        RenderInstance instance = get_render_instance(hit_info.instance_id);
        RenderMesh mesh = get_render_mesh(instance.i_render_mesh);

        // -- Fetch geometry information
        u32    i_v0 = get_index(mesh.first_index + hit_info.triangle_id + 0);
        u32    i_v1 = get_index(mesh.first_index + hit_info.triangle_id + 1);
        u32    i_v2 = get_index(mesh.first_index + hit_info.triangle_id + 2);
        float3 p0   = get_position(mesh.first_position, i_v0).xyz;
        float3 p1   = get_position(mesh.first_position, i_v1).xyz;
        float3 p2   = get_position(mesh.first_position, i_v2).xyz;
        float3 e1 = p1 - p0;
        float3 e2 = p2 - p0;

        float3 surface_normal = normalize(cross(e1, e2));

        float3 tangent;
        float3 bitangent;
        make_orthogonal_coordinate_system(surface_normal, bitangent, tangent);
        mat3 tangent_to_world = mat3(tangent, bitangent, surface_normal);
        mat3 world_to_tangent = transpose(tangent_to_world);

        // -- Material
        const float3 albedo = float3(1.0);
        const float3 emissive = float3(0.0);

        // -- BRDF
        float3 wo = world_to_tangent * -ray.direction;
        float3 wi = lambert_sample(rng_seed);
        float3 brdf = lambert_brdf(wo, wi, albedo);
        float pdf = lambert_pdf(wo, wi) ;

        radiance    += emissive * throughput;
        throughput *= brdf / pdf;

        // -- Bounce
        ray.origin    = (ray.origin + hit_info.d * ray.direction) + surface_normal * 0.001;
        ray.direction = tangent_to_world * wi;
        ray.t_min = 0.0;
        ray.t_max = 5.0;
    }

    imageStore(global_images_2d_rgba32f[storage_output], pixel_pos, float4(radiance, 1.0));
}
