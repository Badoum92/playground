#include "voxels.h"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) uniform VO {
    VoxelOptions voxel_options;
};

layout(set = 0, binding = 1) uniform UBO {
    vec4 sun_direction;
    vec4 point_position;
    float point_scale;
    float traceShadowHit;
    float max_dist;
    float first_step;
};

layout(set = 0, binding = 2) uniform sampler3D voxels_albedo;
layout(set = 0, binding = 3) uniform sampler3D voxels_normal;
layout(set = 0, binding = 4, rgba8) uniform image3D voxels_radiance;

#define EPSILON 0.001

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance)
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;

    float step = voxel_options.size;
    float t = step * floor(first_step); // avoid self shadowing

    vec3 p = position;

    float occlusion = 0.0f;
    float sampled = 0.0f;

    while (occlusion <= 1.0f && t < maxTracingDistance)
    {
        p = position + direction * t;

        vec3 voxel_pos = WorldToVoxelTex(p, voxel_options);
        if (voxel_pos.x < 0.0f || voxel_pos.y < 0.0f || voxel_pos.z < 0.0f
            || voxel_pos.x > 1.0f || voxel_pos.y > 1.0f || voxel_pos.z > 1.0f)
        {
            break;
        }

        sampled = ceil(texture(voxels_albedo, voxel_pos).a) * k;

        // hard shadows mode
        if(sampled > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        occlusion += (1.0f - occlusion) * sampled / t;

        // move further into volume
        t += step;

    }

    occlusion = 1.0 - occlusion;
    return max(occlusion, 0.0);
}

vec3 BRDF(vec3 albedo, vec3 normal, vec3 direction)
{
    float nDotL = 0.0f;
#if 1
    vec3 weight = normal * normal;
    // calculate directional normal attenuation
    float rDotL = dot(vec3(1.0, 0.0, 0.0), direction);
    float uDotL = dot(vec3(0.0, 1.0, 0.0), direction);
    float fDotL = dot(vec3(0.0, 0.0, 1.0), direction);

    rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
    uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
    fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
    // voxel shading average from all front sides
    nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
    nDotL = min(nDotL + 0.25, 1.0);
#else
    nDotL = dot(normal, direction);
#endif
    return albedo * vec3(nDotL);
}

vec4 DirectionalLighting(ivec3 voxel_pos, vec4 albedo, vec3 normal, vec3 light_direction)
{
    vec3 position = VoxelToWorld(voxel_pos, voxel_options);
    // position += normal * 0.5 * voxel_options.size;
    vec3 direction = normalize(light_direction);

    float visibility = TraceShadow(position, direction, 30.0f);
    if (visibility < 0) {
        return vec4(0.0);
    }
    return vec4(BRDF(albedo.rgb, normal, direction)*visibility, visibility);
}

vec4 PointLight(ivec3 voxel_pos, vec4 albedo, vec3 normal, vec3 light_center)
{
    vec3 position = VoxelToWorld(voxel_pos, voxel_options);
    position += normal * 1 * voxel_options.size;

    vec3 light_pos = light_center;

    vec3 direction = light_pos - position;
    float distance = length(direction);
    direction = normalize(direction);

    float falloff = 1 / (distance*distance);
    falloff *= point_scale;

    float visibility = TraceShadow(position, direction, distance) * falloff;

    if (visibility < 0) {
        return vec4(0.0);
    }

    return vec4(BRDF(albedo.rgb, normal, direction)*visibility, visibility);
}

void InjectDirectLighting(ivec3 voxel_pos)
{
    vec4 albedo = texelFetch(voxels_albedo, voxel_pos, 0);

    if (albedo.a < EPSILON) return;

    vec3 normal = texelFetch(voxels_normal, voxel_pos, 0).xyz;
    normal = normalize(DecodeNormal(normal));

    vec4 lighting = vec4(0.0);
    // lighting += DirectionalLighting(voxel_pos, albedo, normal, -sun_direction.xyz);
    lighting += PointLight(voxel_pos, albedo, normal, point_position.xyz);
    lighting.a = 1;

    imageStore(voxels_radiance, voxel_pos, lighting);
}

void main()
{
    ivec3 voxel_pos = ivec3(gl_GlobalInvocationID);

    if (voxel_pos.x > voxel_options.res || voxel_pos.y > voxel_options.res || voxel_pos.z > voxel_options.res) {
        return;
    }

    InjectDirectLighting(voxel_pos);
}
