#version 460
#include "voxels.h"

// layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;

layout(set = 0, binding = 0) uniform VO {
    VoxelOptions voxel_options;
};

layout(set = 0, binding = 1) uniform UBO {
    vec4 sun_direction;
    vec4 point_position;
    float point_scale;
    float traceShadowHit;
    float max_dist;
};

layout(set = 0, binding = 2) uniform sampler3D voxels_albedo;
layout(set = 0, binding = 3) uniform sampler3D voxels_normal;
layout(set = 0, binding = 4, rgba8) uniform image3D voxels_radiance;

#define EPSILON 0.001

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance)
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;

    float step = 1.0f / voxel_options.res;
    float t = step * 2.0f; // avoid self shadowing
    vec3 p = position * step + direction * t;

    float visibility = 0.0f;
    float sampled = 0.0f;

    while (visibility <= 1.0f && t <= maxTracingDistance)
    {
        if (p.x < 0.0f || p.y < 0.0f || p.z < 0.0f
            || p.x > 1.0f || p.y > 1.0f || p.z > 1.0f)
        {
            break;
        }

        sampled = ceil(texture(voxels_albedo, p).a) * k;

        // hard shadows mode
        // if(sampled > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        visibility += (1.0f - visibility) * sampled / t;

        // move further into volume
        t += step;
        p = position * step + direction * t;
    }

    return 1.0f - visibility;
}

vec3 BRDF(vec3 albedo, vec3 normal, vec3 direction)
{
    float nDotL = 0.0f;
    vec3 weight = normal * normal;
    // calculate directional normal attenuation
    float rDotL = dot(vec3(1.0, 0.0, 0.0), direction);
    float uDotL = dot(vec3(0.0, 1.0, 0.0), direction);
    float fDotL = dot(vec3(0.0, 0.0, 1.0), direction);

    rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
    uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
    fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
    // voxel shading average from all front sides
    nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
    return albedo * vec3(nDotL);
}

vec4 DirectionalLighting(ivec3 voxel_pos, vec4 albedo, vec3 normal, vec3 light_direction)
{
    float visibility = TraceShadow(voxel_pos, light_direction, 1.0f);
    if (visibility < 0) {
        return vec4(0.0);
    }
    return vec4(BRDF(albedo.rgb, normal, light_direction)*visibility, visibility);
}

vec4 PointLight(ivec3 voxel_pos, vec4 albedo, vec3 normal, vec3 light_center)
{
    ivec3 light_pos = WorldToVoxel(light_center, voxel_options);
    vec3 direction = light_pos - voxel_pos;
    float distance = length(direction);
    if (distance < EPSILON) {
        return vec4(0.0);
    }
    direction = normalize(direction);
    float falloff = 1 / (distance*distance);
    falloff *= point_scale;

    float visibility = TraceShadow(voxel_pos, direction, distance / voxel_options.res);
    visibility *= falloff;
    if (visibility < 0) {
        return vec4(0.0);
    }
    return vec4(BRDF(albedo.rgb, normal, direction)*visibility, visibility);
}

void InjectDirectLighting(ivec3 voxel_pos)
{
    vec4 albedo = texelFetch(voxels_albedo, voxel_pos, 0);

    if (albedo.a < EPSILON) return;

    vec3 normal = texelFetch(voxels_normal, voxel_pos, 0).xyz;
    normal = DecodeNormal(normal);

    vec4 lighting = vec4(0.0);
    lighting += DirectionalLighting(voxel_pos, albedo, normal, -sun_direction.xyz);
    lighting += PointLight(voxel_pos, albedo, normal, point_position.xyz);
    lighting.a = 1;

    imageStore(voxels_radiance, voxel_pos, lighting);
}

void main()
{
    ivec3 voxel_pos = ivec3(gl_GlobalInvocationID);
    InjectDirectLighting(voxel_pos);
}