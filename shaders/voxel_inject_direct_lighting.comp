#include "types.h"
#include "voxels.h"
#include "globals.h"
#include "maths.h"
#include "csm.h"

#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 1, binding = 0) uniform VO {
    VoxelOptions voxel_options;
};

layout(set = 1, binding = 1) uniform VCTD {
    VCTDebug vct_debug;
};

layout(set = 1, binding = 2) uniform sampler3D voxels_albedo;
layout(set = 1, binding = 3) uniform sampler3D voxels_normal;
layout(set = 1, binding = 4, rgba8) uniform image3D voxels_radiance;

layout (set = 1, binding = 5) uniform CD {
    float4 cascades_depth_slices[4];
};

layout (set = 1, binding = 6) uniform CM {
    CascadeMatrix cascade_matrices[10];
};

layout(set = 1, binding = 7) uniform sampler2D shadow_cascades[4];


float ray_trace_voxel_occlusion(int3 voxel_origin, float3 direction)
{
    float occlusion = 0.0;

    float3 origin = float3(voxel_origin) / float3(voxel_options.res);
    float step = 0.5 * 1 / voxel_options.res;

    float t = 1.2 * step;

    for (uint iter = 0; iter < 5000 && occlusion < 1.0; iter++)
    {
        float3 p = origin + t * direction;

        if (any(greaterThan(p, float3(1.0))) || any(lessThan(p, float3(0.0))))
        {
            break;
        }

        float sampled = float(texture(voxels_albedo, p).a > 0.001);

        occlusion += sampled * 1 / 5;

        t += step;
    }

    return clamp(occlusion, 0, 1);
}

void main()
{
    ivec3 voxel_pos = ivec3(gl_GlobalInvocationID);
    if (voxel_pos.x > voxel_options.res || voxel_pos.y > voxel_options.res || voxel_pos.z > voxel_options.res) {
        return;
    }

    vec4 albedo = texelFetch(voxels_albedo, voxel_pos, 0);

    if (albedo.a <= 0.001) {
        return;
    }

    vec3 normal = texelFetch(voxels_normal, voxel_pos, 0).xyz;
    normal = normalize(DecodeNormal(normal));

    float3 world_pos = VoxelCenterToWorld(voxel_pos, voxel_options);

    float occlusion = ray_trace_voxel_occlusion(voxel_pos, global.sun_direction);
    float visibility = 1.0 - occlusion;
    float4 lighting = float4(visibility * global.sun_illuminance * albedo.rgb, 1.0);

    imageStore(voxels_radiance, voxel_pos, lighting);
}
