#include "types.h"
#include "constants.h"

layout (set = 1, binding = 0) uniform sampler2D hdr_texture;

layout (set = 1, binding = 1) buffer LH {
    uint luminance_histogram[];
};

layout (set = 1, binding = 2) uniform LUM
{
    uint input_width;
    uint input_height;
    float min_log_luminance;
    float one_over_log_luminance_range;
};

float get_luminance(float3 color)
{
    return dot(color, float3(0.2127f, 0.7152f, 0.0722f));
}

uint hdr_to_histogram_bin(float3 color)
{
    float luminance = get_luminance(color);

    if (luminance < 0.01)
    {
        return 0;
    }

    float log_luminance = clamp((log2(luminance) - min_log_luminance) * one_over_log_luminance_range, 0.0, 1.0);
    return uint(log_luminance * 254.0 + 1.0);
}

shared uint histogram_shared[256];

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    uint local_idx = gl_LocalInvocationIndex;
    uint3 thread_id = gl_GlobalInvocationID;

    // every invocation of this group will clear the shared memory to 0
    histogram_shared[local_idx] = 0;

    groupMemoryBarrier();
    barrier();

    // every global invocation maps to one pixel of the input texture
    // add it to the histogram
    int2 pixel_pos = int2(thread_id.xy);
    int2 input_size = textureSize(hdr_texture, LOD0);
    if(all(lessThan(pixel_pos, input_size)))
    {
        float3 hdr_color = texelFetch(hdr_texture, pixel_pos, 0).rgb;
        uint bin_idx = hdr_to_histogram_bin(hdr_color);

        atomicAdd(histogram_shared[bin_idx], 1);
    }

    groupMemoryBarrier();
    barrier();

    // the local shared histogram is full now,
    // so add the shared histogram to the global one
    atomicAdd(luminance_histogram[local_idx], histogram_shared[local_idx]);
}
