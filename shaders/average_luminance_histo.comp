#include "globals.h"

layout (set = 1, binding = 0, r32f) uniform image2D luminance_output;

layout (set = 1, binding = 1) buffer LH {
    uint luminance_histogram[];
};

layout (set = 1, binding = 2) uniform LUM
{
    uint  pixel_count;
    float min_log_luminance;
    float log_luminance_range;
    float tau;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

shared float histogram_shared[256];

void main()
{
    uint local_idx = gl_LocalInvocationIndex;

    // weigh every bin with the value from the histogram
    float count = float(luminance_histogram[local_idx]);
    histogram_shared[local_idx] = count * float(local_idx);

    groupMemoryBarrier();
    barrier();

    // summ all values in histogram_shared to histogram_shared[0]
    for (uint sample_idx = (256 >> 1); sample_idx > 0; sample_idx >>= 1)
    {
        if(local_idx < sample_idx)
        {
            histogram_shared[local_idx] += histogram_shared[local_idx + sample_idx];
        }

        groupMemoryBarrier();
        barrier();
    }

    // only the first invocation will do the final store
    if (local_idx == 0)
    {
        float weighted_log_average = (histogram_shared[0].x / max(float(pixel_count) - count, 1.0)) - 1.0;
        float weighted_average_luminance = exp2(((weighted_log_average / 254.0) * log_luminance_range) + min_log_luminance);
        float previous_luminance = imageLoad(luminance_output, int2(0, 0)).r;

        float adapted_luminance = previous_luminance + (weighted_average_luminance - previous_luminance) * (1 - exp(-global.delta_t * tau));
        imageStore(luminance_output, int2(0, 0), float4(adapted_luminance, 0.0, 0.0, 0.0));
    }
}
