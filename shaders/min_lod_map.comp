layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "globals.h"

layout(set = 0, binding = 1) uniform usampler2D screenspace_lod_map;
layout(set = 0, binding = 2) uniform sampler2D depth_buffer;
layout(set = 0, binding = 3, r32ui) uniform uimage2D min_lod_map;

void main()
{
    ivec2 pixel_src   = ivec2(gl_GlobalInvocationID.xy);
    float2 screen_size = float2(textureSize(screenspace_lod_map, 0));
    if (any(greaterThan(pixel_src, screen_size))) {
        return;
    }

    float depth = texelFetch(depth_buffer, pixel_src, 0).r;

    float3 clip_space = float3((pixel_src / screen_size) * 2.0 - float2(1.0), depth);

    // reconstruct world position from the depth and the fragment position
    vec4 world_pos = global.camera_inv_view_proj * float4(clip_space, 1.0);
    world_pos /= world_pos.w;

    // project to light space
    vec4 sun_pos = global.sun_proj * global.sun_view * world_pos;

    // uv of the shadow map
    vec2 uv = sun_pos.xy;

    uv += vec2(0.5); // ???

    // desired lod of the shadow map at that uv
    uint shadowmap_lod = texelFetch(screenspace_lod_map, pixel_src, 0).r;

    /// --- find which tile corresponds to that shadowmap's uv

    const ivec2 image_size = imageSize(min_lod_map);

    ivec2 tile = ivec2(
        int(uv.x * image_size),
        int(uv.y * image_size)
        );


    // only r value will be written to R8Uint texture
    vec4 value = vec4(shadowmap_lod / 6, 0.0, 0.0, 0.0);
    imageAtomicMin(min_lod_map, tile, shadowmap_lod);
}
