#include "globals.h"
#include "atmosphere.h"

layout (set = 0, binding = 0) uniform AtmosphereUniform {
    AtmosphereParameters atmosphere;
};

layout(set = 0, binding = 1) uniform sampler2D transmittance_lut; // sampler linear clamp
layout(set = 0, binding = 2) uniform writeonly image2D multiscattering_lut;

void preintegrate_multiscattering(AtmosphereParameters atmosphere, out float3 L, out float3 Lf, float3 p, float3 dir, float3 sun_dir)
{
    float3 throughput = float3(1.0);
    L  = float3(0.0);
    Lf = float3(0.0);

    float r    = length(p);
    float mu   = dot(p / r, dir);
    float mu_s = dot(p, sun_dir) / r;
    float v    = dot(dir, sun_dir);

    const int SAMPLE_COUNT = 40;
    bool intersects_ground = intersects_ground(atmosphere, r, mu);
    float nearest_atmosphere = distance_to_nearest_atmosphere(atmosphere, r, mu, intersects_ground);
    float dx =  nearest_atmosphere / SAMPLE_COUNT;

    for (int i = 0; i <= SAMPLE_COUNT; i++)
    {
        float d = i * dx;
        float rd = safe_sqrt(d * d + r * r + 2 * r * d * mu);
        float mu_s_d = (r * mu_s + d * v) / rd;

        MediumRGB medium = sample_medium(atmosphere, rd);
        float3 sample_transmittance = exp(-medium.extinction * dx);

        float3 sun_transmittance = get_transmittance_to_sun(atmosphere, transmittance_lut, rd, mu_s_d);

        float3 os = medium.scattering;
        float3 T = sun_transmittance;
        float3 S = float3(1.0); // todo?
        float pu = uniform_phase;
        float3 Ei = float3(1.0);

        // L′(x,v) = T(x,p) Lo(p,v) +∫_{t=0}^{‖p−x‖} σs(x) T(x,x−tv) S(x,ωs) pu EI dt      (6)
        float3 L_integrand = os * T * S * pu * Ei;

        /// --- Integrate scattering

        // Lf(x,v) =∫_{t=0}^{‖p−x‖} σs(x) T(x,x−tv) 1 dt     (8)
        // Integration formula, see slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        float3 Lf_integrand = medium.scattering * 1;
        float3 Lf_int = (Lf_integrand - Lf_integrand * sample_transmittance) / medium.extinction; // integrate along the current step segment
        Lf += throughput * Lf_int;                                                                // accumulate and also take into account the transmittance from previous steps

        // same as above
        float3 L_int = (L_integrand - L_integrand * sample_transmittance) / medium.extinction;
        L += throughput * L_int;

        throughput *= sample_transmittance;
    }


    // Account for bounced light off the earth
    if (intersects_ground)
    {
        float3 intersection = p + nearest_atmosphere * dir;
        float inter_r = length(intersection);

        float mu_s = dot(intersection, sun_dir) / inter_r;
        float3 sun_transmittance = get_transmittance_to_sun(atmosphere, transmittance_lut, inter_r, mu_s);

        const float3 up = intersection / inter_r;
        const float n_dot_l = clamp(dot(up, sun_dir), 0.0, 1.0);
        L += float3(1.0) * sun_transmittance * throughput * n_dot_l * atmosphere.ground_albedo / PI;
    }
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 64) in;

shared float3 Lf_shared[64];
shared float3 L_shared[64];

void main()
{
    float2 lut_size = imageSize(multiscattering_lut);
    float2 uv = (gl_GlobalInvocationID.xy + float2(0.5)) / lut_size;
    uv = uv_to_unit(uv, lut_size);

    float mu = uv.x * 2.0 - 1.0;
    float3 sun_dir = float3(0.0, mu, sqrt(clamp(1.0 - mu * mu, 0.0, 1.0)));

    float r = atmosphere.bottom_radius + uv.y * (atmosphere.top_radius - atmosphere.bottom_radius);


    float3 p = float3(0.0, r, 0.0);
    float3 dir = float3(0.0, 1.0, 0.0);

    const float sphere_solid_angle = 4.0 * PI;
    const float isotropic_phase = 1.0 / sphere_solid_angle;

    const float SQRT_SAMPLE_COUNT = 8.0;
    float i = 0.5 + float(gl_GlobalInvocationID.z / SQRT_SAMPLE_COUNT);
    float j = 0.5 + float(gl_GlobalInvocationID.z - float((gl_GlobalInvocationID.z / SQRT_SAMPLE_COUNT) * SQRT_SAMPLE_COUNT));
    {
            float rand_a    = i / SQRT_SAMPLE_COUNT;
            float rand_b    = j / SQRT_SAMPLE_COUNT;
            float theta     = 2.0 * PI * rand_a;
            float phi       = PI * rand_b;
            float cos_phi   = cos(phi);
            float sin_phi   = sin(phi);
            float cos_theta = cos(theta);
            float sin_theta = sin(theta);
            dir.x = cos_theta * sin_phi;
            dir.y = cos_phi;
            dir.z = sin_theta * sin_phi;

            float3 L;
            float3 Lf;

            preintegrate_multiscattering(atmosphere, L, Lf, p, dir, sun_dir);

            Lf_shared[gl_GlobalInvocationID.z] = Lf * sphere_solid_angle / (SQRT_SAMPLE_COUNT * SQRT_SAMPLE_COUNT);
            L_shared[gl_GlobalInvocationID.z]  = L  * sphere_solid_angle / (SQRT_SAMPLE_COUNT * SQRT_SAMPLE_COUNT);
    }

    barrier();

    // 64 to 32
    if (gl_GlobalInvocationID.z < 32)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 32];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 32];
    }

    barrier();

    // 32 to 16
    if (gl_GlobalInvocationID.z < 16)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 16];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 16];
    }

    barrier();

    // 16 to 8 (16 is thread group min hardware size with intel, no sync required from there)
    if (gl_GlobalInvocationID.z < 8)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 8];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 8];
    }

    barrier();

    if (gl_GlobalInvocationID.z < 4)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 4];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 4];
    }

    barrier();

    if (gl_GlobalInvocationID.z < 2)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 2];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 2];
    }

    barrier();

    if (gl_GlobalInvocationID.z < 1)
    {
        Lf_shared[gl_GlobalInvocationID.z] += Lf_shared[gl_GlobalInvocationID.z + 1];
        L_shared[gl_GlobalInvocationID.z]  += L_shared[gl_GlobalInvocationID.z + 1];
    }

    barrier();

    if (gl_GlobalInvocationID.z > 0)
        return;

    // fms =∫_{Ω4π} Lf(xs,−ω) pu dω           (7)
    float3 fms   = Lf_shared[0] * isotropic_phase;

    // L_2nd_order = ∫_{Ω4π} L′(xs,−ω) pu dω (5)
    float3 L_2nd = L_shared[0] * isotropic_phase;

    // fms represents the amount of luminance scattered as if the integral of scattered luminance over the sphere would be 1.
    //  - 1st order of scattering: one can ray-march a straight path as usual over the sphere. That is L_2nd.
    //  - 2nd order of scattering: the inscattered luminance is L_2nd at each of samples of fist order integration. Assuming a uniform phase function that is represented by fms,
    //  - 3nd order of scattering: the inscattered luminance is (L_2nd * fms * fms)
    //  - etc.

    // Fms = 1 + fms + fms^2 + fms^3 + ... = 1 / (1 − fms)        (9)
    const float3 Fms = 1.0f / (1.0 - fms);

    // Ψms = L_2nd_order Fms                 (10)
    float3 psi_ms = L_2nd * Fms;

    imageStore(multiscattering_lut, int2(gl_GlobalInvocationID.xy), float4(psi_ms, 1.0));
}

#if 0
SingleScatteringResult IntegrateScatteredLuminance(
    float2 pixPos, float3 WorldPos, float3 WorldDir, float3 SunDir, AtmosphereParameters Atmosphere,
    bool ground, float SampleCountIni, float DepthBufferValue, bool VariableSampleCount,
    bool MieRayPhase, float tMaxMax)
{
    SingleScatteringResult result;

    float3 ClipSpace = float3((pixPos / float2(global.resolution))*float2(2.0, -2.0) - float2(1.0, -1.0), 1.0);

    // Compute next intersection with atmosphere or ground
    float3 earthO = float3(0.0f, 0.0f, 0.0f);
    float tBottom = raySphereIntersectNearest(WorldPos, WorldDir, earthO, Atmosphere.BottomRadius);
    float tTop = raySphereIntersectNearest(WorldPos, WorldDir, earthO, Atmosphere.TopRadius);
    float tMax = 0.0f;
    if (tBottom < 0.0f)
    {
        if (tTop < 0.0f)
        {
            tMax = 0.0f; // No intersection with earth nor atmosphere: stop right away
            return result;
        }
        else
        {
            tMax = tTop;
        }
    }
    else
    {
        if (tTop > 0.0f)
        {
            tMax = min(tTop, tBottom);
        }
    }
    tMax = min(tMax, tMaxMax);

    // Sample count
    float SampleCount = SampleCountIni;
    float SampleCountFloor = SampleCountIni;
    float tMaxFloor = tMax;
    if (VariableSampleCount)
    {
        SampleCount = mix(global.raymarch_min_max_spp.x, global.raymarch_min_max_spp.y, clamp(tMax*0.01, 0.0, 1.0));
        SampleCountFloor = floor(SampleCount);
        tMaxFloor = tMax * SampleCountFloor / SampleCount;    // rescale tMax to map to the last entire step segment.
    }
    float dt = tMax / SampleCount;

    // Phase functions
    const float uniformPhase = 1.0 / (4.0 * PI);
    const float3 wi = SunDir;
    const float3 wo = WorldDir;
    float cosTheta = dot(wi, wo);
    float MiePhaseValue = hgPhase(Atmosphere.MiePhaseG, -cosTheta);    // mnegate cosTheta because due to WorldDir being a "in" direction.
    float RayleighPhaseValue = RayleighPhase(cosTheta);

    // When building the scattering factor, we assume light illuminance is 1 to compute a transfert function relative to identity illuminance of 1.
    // This make the scattering factor independent of the light. It is now only linked to the atmosphere properties.
    float3 globalL = float3(1.0f);

    // Ray march the atmosphere to integrate optical depth
    float3 L = float3(0.0f);
    float3 throughput = float3(1.0);
    float t = 0.0f;
    float tPrev = 0.0;
    const float SampleSegmentT = 0.3f;
    for (float s = 0.0f; s < SampleCount; s += 1.0f)
    {
        if (VariableSampleCount)
        {
            // More expenssive but artefact free
            float t0 = (s) / SampleCountFloor;
            float t1 = (s + 1.0f) / SampleCountFloor;
            // Non linear distribution of sample within the range.
            t0 = t0 * t0;
            t1 = t1 * t1;
            // Make t0 and t1 world space distances.
            t0 = tMaxFloor * t0;
            if (t1 > 1.0)
            {
                t1 = tMax;
                //    t1 = tMaxFloor;    // this reveal depth slices
            }
            else
            {
                t1 = tMaxFloor * t1;
            }
            //t = t0 + (t1 - t0) * (whangHashNoise(pixPos.x, pixPos.y, gFrameId * 1920 * 1080)); // With dithering required to hide some sampling artefact relying on TAA later? This may even allow volumetric shadow?
            t = t0 + (t1 - t0)*SampleSegmentT;
            dt = t1 - t0;
        }
        else
        {
            //t = tMax * (s + SampleSegmentT) / SampleCount;
            // Exact difference, important for accuracy of multiple scattering
            float NewT = tMax * (s + SampleSegmentT) / SampleCount;
            dt = NewT - t;
            t = NewT;
        }
        float3 P = WorldPos + t * WorldDir;

        MediumSampleRGB medium = sampleMediumRGB(P, Atmosphere);
        const float3 SampleOpticalDepth = medium.extinction * dt;
        const float3 SampleTransmittance = exp(-SampleOpticalDepth);

        float pHeight = length(P);
        const float3 UpVector = P / pHeight;
        float SunZenithCosAngle = dot(SunDir, UpVector);
        float2 uv;
        LutTransmittanceParamsToUv(Atmosphere, pHeight, SunZenithCosAngle, uv);
        float3 TransmittanceToSun = textureLod(TransmittanceLutTexture, uv, 0).rgb;

        float3 PhaseTimesScattering = medium.scattering * uniformPhase;

        // Earth shadow
        float tEarth = raySphereIntersectNearest(P, SunDir, earthO + PLANET_RADIUS_OFFSET * UpVector, Atmosphere.BottomRadius);
        float earthShadow = tEarth >= 0.0f ? 0.0f : 1.0f;

        // Lscat?  E_i       *  S    (vis             *  T)                *  p
        float3 S = float3(1.0) * (earthShadow * TransmittanceToSun) * PhaseTimesScattering;

        float3 MS = medium.scattering * 1;
        float3 MSint = (MS - MS * SampleTransmittance) / medium.extinction;
        result.MultiScatAs1 += throughput * MSint;

        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        float3 Sint = (S - S * SampleTransmittance) / medium.extinction;    // integrate along the current step segment
        L += throughput * Sint;                                                        // accumulate and also take into account the transmittance from previous steps
        throughput *= SampleTransmittance;

        tPrev = t;
    }

    if (ground && tMax == tBottom && tBottom > 0.0)
    {
        // Account for bounced light off the earth
        float3 P = WorldPos + tBottom * WorldDir;
        float pHeight = length(P);

        const float3 UpVector = P / pHeight;
        float SunZenithCosAngle = dot(SunDir, UpVector);
        float2 uv;
        LutTransmittanceParamsToUv(Atmosphere, pHeight, SunZenithCosAngle, uv);
        float3 TransmittanceToSun = textureLod(TransmittanceLutTexture, uv, 0).rgb;

        const float NdotL = clamp(dot(normalize(UpVector), normalize(SunDir)), 0.0, 1.0);
        L += float3(1.0) * TransmittanceToSun * throughput * NdotL * Atmosphere.GroundAlbedo / PI;
    }

    result.L = L;
    result.Transmittance = throughput;
    return result;
}
#endif
